{"ast":null,"code":"import _regeneratorRuntime from \"/Users/vadym/Documents/work/job/wedge/node_modules/@babel/runtime/regenerator\";\n\nvar _marked =\n/*#__PURE__*/\n_regeneratorRuntime.mark(stripeSourceSaga),\n    _marked2 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(createStripeSource),\n    _marked3 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(registerStripeSource),\n    _marked4 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(contractIdSaga),\n    _marked5 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(finishRegistrationProcedure);\n\nimport { call, put, select } from 'redux-saga/effects';\nimport get from 'lodash/get'; // import jwt from 'jsonwebtoken'\n\nimport { setStripeError, setContractIdError } from '../payment/actions';\nimport { PAYMENT } from '../../constants/reducersNames';\nimport { STRIPE } from '../payment/propertiesNames';\nimport { startLoading, finishLoading } from '../user/actions';\nimport { createCustomer } from './apiCalls';\nimport history from '../../history'; // import { LOCAL_ACCESS_TOKEN_KEY } from '../../enums'\n// import { extractCustomers } from '../../utils/utils'\n\nimport { logoutUser } from '../auth/actions';\nimport { extractResponseErrorStatus, createResponseErrorMessage } from '../../utils/responseErrorHandler';\n\nvar stripeInSagaSelector = function stripeInSagaSelector(state) {\n  var stripeInstance = get(state, [PAYMENT, STRIPE]);\n  return stripeInstance;\n};\n\nexport function stripeSourceSaga(_ref) {\n  var userData, responseAfterCallingStripeApi, userDataVerifiedByStripe, errorStatus, errorMessage;\n  return _regeneratorRuntime.wrap(function stripeSourceSaga$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          userData = _ref.payload;\n          _context.next = 3;\n          return put(startLoading());\n\n        case 3:\n          _context.prev = 3;\n          _context.next = 6;\n          return call(createStripeSource, userData);\n\n        case 6:\n          responseAfterCallingStripeApi = _context.sent;\n          userDataVerifiedByStripe = responseAfterCallingStripeApi.source;\n          _context.next = 10;\n          return call(registerStripeSource, userDataVerifiedByStripe);\n\n        case 10:\n          _context.next = 12;\n          return call(finishRegistrationProcedure);\n\n        case 12:\n          _context.next = 25;\n          break;\n\n        case 14:\n          _context.prev = 14;\n          _context.t0 = _context[\"catch\"](3);\n\n          if (!(typeof _context.t0 === 'string')) {\n            _context.next = 21;\n            break;\n          }\n\n          _context.next = 19;\n          return put(setStripeError(_context.t0));\n\n        case 19:\n          _context.next = 25;\n          break;\n\n        case 21:\n          errorStatus = extractResponseErrorStatus(_context.t0);\n          errorMessage = createResponseErrorMessage({\n            specificErrorHandler: {\n              default: 'Error while generating Stripe Source Id'\n            },\n            status: errorStatus\n          });\n          _context.next = 25;\n          return put(setStripeError(errorMessage));\n\n        case 25:\n          _context.prev = 25;\n          _context.next = 28;\n          return put(finishLoading());\n\n        case 28:\n          return _context.finish(25);\n\n        case 29:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, this, [[3, 14, 25, 29]]);\n}\nexport function createStripeSource(userData) {\n  var stripe, response, error, message;\n  return _regeneratorRuntime.wrap(function createStripeSource$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return select(stripeInSagaSelector);\n\n        case 2:\n          stripe = _context2.sent;\n          _context2.next = 5;\n          return stripe.createSource(userData);\n\n        case 5:\n          response = _context2.sent;\n          error = response.error;\n\n          if (!error) {\n            _context2.next = 10;\n            break;\n          }\n\n          message = error.message;\n          throw message;\n\n        case 10:\n          return _context2.abrupt(\"return\", response);\n\n        case 11:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, this);\n}\nexport function registerStripeSource(userData) {\n  var payment_channel, payment_ref, _userData$owner, name, address, requestBody, response, field;\n\n  return _regeneratorRuntime.wrap(function registerStripeSource$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          //ATTENTION!! With payment_channel I specify,\n          // if the Stripe Source Id or Contract Id is provided\n          // as payment_ref\n          payment_channel = STRIPE;\n          payment_ref = userData.id, _userData$owner = userData.owner, name = _userData$owner.name, address = _userData$owner.address;\n          _context3.prev = 2;\n          requestBody = {\n            payment_channel: payment_channel,\n            payment_ref: payment_ref,\n            name: name,\n            address: address\n          };\n          _context3.next = 6;\n          return call(createCustomer, requestBody);\n\n        case 6:\n          response = _context3.sent;\n          return _context3.abrupt(\"return\", response);\n\n        case 10:\n          _context3.prev = 10;\n          _context3.t0 = _context3[\"catch\"](2);\n          field = _context3.t0.field;\n\n          if (!field) {\n            _context3.next = 15;\n            break;\n          }\n\n          throw \"Invalid Data Passed As \\\"\".concat(field, \"\\\"\");\n\n        case 15:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, this, [[2, 10]]);\n}\nexport function contractIdSaga(_ref2) {\n  var companyData, field, errorStatus, errorMessage;\n  return _regeneratorRuntime.wrap(function contractIdSaga$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          companyData = _ref2.payload;\n          _context4.next = 3;\n          return put(startLoading());\n\n        case 3:\n          _context4.prev = 3;\n          _context4.next = 6;\n          return call(createCustomer, companyData);\n\n        case 6:\n          _context4.next = 8;\n          return call(finishRegistrationProcedure);\n\n        case 8:\n          _context4.next = 17;\n          break;\n\n        case 10:\n          _context4.prev = 10;\n          _context4.t0 = _context4[\"catch\"](3);\n          field = _context4.t0.field;\n          errorStatus = extractResponseErrorStatus(_context4.t0);\n          errorMessage = field ? \"Invalid Data Passed As \\\"\".concat(field, \"\\\"\") : createResponseErrorMessage({\n            specificErrorHandler: {\n              default: 'Error while generating Stripe Source Id'\n            },\n            status: errorStatus\n          });\n          _context4.next = 17;\n          return put(setContractIdError(errorMessage));\n\n        case 17:\n          _context4.prev = 17;\n          _context4.next = 20;\n          return put(finishLoading());\n\n        case 20:\n          return _context4.finish(17);\n\n        case 21:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4, this, [[3, 10, 17, 21]]);\n}\nexport function finishRegistrationProcedure() {\n  return _regeneratorRuntime.wrap(function finishRegistrationProcedure$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return put(logoutUser());\n\n        case 2:\n          history.push('/');\n\n        case 3:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5, this);\n}","map":{"version":3,"sources":["/Users/vadym/Documents/work/job/wedge/src/store/sagas/billingRegistrationSagas.js"],"names":["stripeSourceSaga","createStripeSource","registerStripeSource","contractIdSaga","finishRegistrationProcedure","call","put","select","get","setStripeError","setContractIdError","PAYMENT","STRIPE","startLoading","finishLoading","createCustomer","history","logoutUser","extractResponseErrorStatus","createResponseErrorMessage","stripeInSagaSelector","state","stripeInstance","userData","payload","responseAfterCallingStripeApi","userDataVerifiedByStripe","source","errorStatus","errorMessage","specificErrorHandler","default","status","stripe","createSource","response","error","message","payment_channel","payment_ref","id","owner","name","address","requestBody","field","companyData","push"],"mappings":";;;;yBAuBiBA,gB;;;yBA4BAC,kB;;;yBAWAC,oB;;;yBAyBAC,c;;;yBAsBAC,2B;;AA7GjB,SAASC,IAAT,EAAeC,GAAf,EAAoBC,MAApB,QAAkC,oBAAlC;AACA,OAAOC,GAAP,MAAgB,YAAhB,C,CACA;;AAEA,SAASC,cAAT,EAAyBC,kBAAzB,QAAmD,oBAAnD;AACA,SAASC,OAAT,QAAwB,+BAAxB;AACA,SAASC,MAAT,QAAuB,4BAAvB;AACA,SAASC,YAAT,EAAuBC,aAAvB,QAA4C,iBAA5C;AACA,SAASC,cAAT,QAA+B,YAA/B;AACA,OAAOC,OAAP,MAAoB,eAApB,C,CACA;AACA;;AACA,SAASC,UAAT,QAA2B,iBAA3B;AACA,SACCC,0BADD,EAECC,0BAFD,QAGO,kCAHP;;AAKA,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAAC,KAAK,EAAI;AACrC,MAAMC,cAAc,GAAGd,GAAG,CAACa,KAAD,EAAQ,CAACV,OAAD,EAAUC,MAAV,CAAR,CAA1B;AACA,SAAOU,cAAP;AACA,CAHD;;AAKA,OAAO,SAAUtB,gBAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsCuB,UAAAA,QAAtC,QAA6BC,OAA7B;AAAA;AACN,iBAAMlB,GAAG,CAACO,YAAY,EAAb,CAAT;;AADM;AAAA;AAAA;AAGiC,iBAAMR,IAAI,CAC/CJ,kBAD+C,EAE/CsB,QAF+C,CAAV;;AAHjC;AAGCE,UAAAA,6BAHD;AAOWC,UAAAA,wBAPX,GAOwCD,6BAPxC,CAOGE,MAPH;AAAA;AAQL,iBAAMtB,IAAI,CAACH,oBAAD,EAAuBwB,wBAAvB,CAAV;;AARK;AAAA;AASL,iBAAMrB,IAAI,CAACD,2BAAD,CAAV;;AATK;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,gBAWD,uBAAiB,QAXhB;AAAA;AAAA;AAAA;;AAAA;AAYJ,iBAAME,GAAG,CAACG,cAAc,aAAf,CAAT;;AAZI;AAAA;AAAA;;AAAA;AAcEmB,UAAAA,WAdF,GAcgBV,0BAA0B,aAd1C;AAeEW,UAAAA,YAfF,GAeiBV,0BAA0B,CAAC;AAC/CW,YAAAA,oBAAoB,EAAE;AACrBC,cAAAA,OAAO,EAAE;AADY,aADyB;AAI/CC,YAAAA,MAAM,EAAEJ;AAJuC,WAAD,CAf3C;AAAA;AAqBJ,iBAAMtB,GAAG,CAACG,cAAc,CAACoB,YAAD,CAAf,CAAT;;AArBI;AAAA;AAAA;AAwBL,iBAAMvB,GAAG,CAACQ,aAAa,EAAd,CAAT;;AAxBK;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BP,OAAO,SAAUb,kBAAV,CAA6BsB,QAA7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACS,iBAAMhB,MAAM,CAACa,oBAAD,CAAZ;;AADT;AACAa,UAAAA,MADA;AAAA;AAEW,iBAAMA,MAAM,CAACC,YAAP,CAAoBX,QAApB,CAAN;;AAFX;AAEAY,UAAAA,QAFA;AAGEC,UAAAA,KAHF,GAGYD,QAHZ,CAGEC,KAHF;;AAAA,eAIFA,KAJE;AAAA;AAAA;AAAA;;AAKGC,UAAAA,OALH,GAKeD,KALf,CAKGC,OALH;AAAA,gBAMCA,OAND;;AAAA;AAAA,4CAQCF,QARD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWP,OAAO,SAAUjC,oBAAV,CAA+BqB,QAA/B;AAAA;;AAAA;AAAA;AAAA;AAAA;AACN;AACA;AACA;AACMe,UAAAA,eAJA,GAIkB1B,MAJlB;AAMD2B,UAAAA,WANC,GAQFhB,QARE,CAMLiB,EANK,oBAQFjB,QARE,CAOLkB,KAPK,EAOIC,IAPJ,mBAOIA,IAPJ,EAOUC,OAPV,mBAOUA,OAPV;AAAA;AAUCC,UAAAA,WAVD,GAUe;AACnBN,YAAAA,eAAe,EAAfA,eADmB;AAEnBC,YAAAA,WAAW,EAAXA,WAFmB;AAGnBG,YAAAA,IAAI,EAAJA,IAHmB;AAInBC,YAAAA,OAAO,EAAPA;AAJmB,WAVf;AAAA;AAgBY,iBAAMtC,IAAI,CAACU,cAAD,EAAiB6B,WAAjB,CAAV;;AAhBZ;AAgBCT,UAAAA,QAhBD;AAAA,4CAiBEA,QAjBF;;AAAA;AAAA;AAAA;AAmBGU,UAAAA,KAnBH,gBAmBGA,KAnBH;;AAAA,eAoBDA,KApBC;AAAA;AAAA;AAAA;;AAAA,mDAqB6BA,KArB7B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBP,OAAO,SAAU1C,cAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC2C,UAAAA,WAApC,SAA2BtB,OAA3B;AAAA;AACN,iBAAMlB,GAAG,CAACO,YAAY,EAAb,CAAT;;AADM;AAAA;AAAA;AAGL,iBAAMR,IAAI,CAACU,cAAD,EAAiB+B,WAAjB,CAAV;;AAHK;AAAA;AAIL,iBAAMzC,IAAI,CAACD,2BAAD,CAAV;;AAJK;AAAA;AAAA;;AAAA;AAAA;AAAA;AAMGyC,UAAAA,KANH,gBAMGA,KANH;AAOCjB,UAAAA,WAPD,GAOeV,0BAA0B,cAPzC;AAQCW,UAAAA,YARD,GAQgBgB,KAAK,sCACIA,KADJ,UAEvB1B,0BAA0B,CAAC;AAC3BW,YAAAA,oBAAoB,EAAE;AACrBC,cAAAA,OAAO,EAAE;AADY,aADK;AAI3BC,YAAAA,MAAM,EAAEJ;AAJmB,WAAD,CAVxB;AAAA;AAgBL,iBAAMtB,GAAG,CAACI,kBAAkB,CAACmB,YAAD,CAAnB,CAAT;;AAhBK;AAAA;AAAA;AAkBL,iBAAMvB,GAAG,CAACQ,aAAa,EAAd,CAAT;;AAlBK;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBP,OAAO,SAAUV,2BAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AASN,iBAAME,GAAG,CAACW,UAAU,EAAX,CAAT;;AATM;AAUND,UAAAA,OAAO,CAAC+B,IAAR,CAAa,GAAb;;AAVM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["import { call, put, select } from 'redux-saga/effects'\nimport get from 'lodash/get'\n// import jwt from 'jsonwebtoken'\n\nimport { setStripeError, setContractIdError } from '../payment/actions'\nimport { PAYMENT } from '../../constants/reducersNames'\nimport { STRIPE } from '../payment/propertiesNames'\nimport { startLoading, finishLoading } from '../user/actions'\nimport { createCustomer } from './apiCalls'\nimport history from '../../history'\n// import { LOCAL_ACCESS_TOKEN_KEY } from '../../enums'\n// import { extractCustomers } from '../../utils/utils'\nimport { logoutUser } from '../auth/actions'\nimport {\n\textractResponseErrorStatus,\n\tcreateResponseErrorMessage\n} from '../../utils/responseErrorHandler'\n\nconst stripeInSagaSelector = state => {\n\tconst stripeInstance = get(state, [PAYMENT, STRIPE])\n\treturn stripeInstance\n}\n\nexport function* stripeSourceSaga({ payload: userData }) {\n\tyield put(startLoading())\n\ttry {\n\t\tconst responseAfterCallingStripeApi = yield call(\n\t\t\tcreateStripeSource,\n\t\t\tuserData\n\t\t)\n\t\tconst { source: userDataVerifiedByStripe } = responseAfterCallingStripeApi\n\t\tyield call(registerStripeSource, userDataVerifiedByStripe)\n\t\tyield call(finishRegistrationProcedure)\n\t} catch (error) {\n\t\tif (typeof error === 'string') {\n\t\t\tyield put(setStripeError(error))\n\t\t} else {\n\t\t\tconst errorStatus = extractResponseErrorStatus(error)\n\t\t\tconst errorMessage = createResponseErrorMessage({\n\t\t\t\tspecificErrorHandler: {\n\t\t\t\t\tdefault: 'Error while generating Stripe Source Id'\n\t\t\t\t},\n\t\t\t\tstatus: errorStatus\n\t\t\t})\n\t\t\tyield put(setStripeError(errorMessage))\n\t\t}\n\t} finally {\n\t\tyield put(finishLoading())\n\t}\n}\n\nexport function* createStripeSource(userData) {\n\tconst stripe = yield select(stripeInSagaSelector)\n\tconst response = yield stripe.createSource(userData)\n\tconst { error } = response\n\tif (error) {\n\t\tconst { message } = error\n\t\tthrow message\n\t}\n\treturn response\n}\n\nexport function* registerStripeSource(userData) {\n\t//ATTENTION!! With payment_channel I specify,\n\t// if the Stripe Source Id or Contract Id is provided\n\t// as payment_ref\n\tconst payment_channel = STRIPE\n\tconst {\n\t\tid: payment_ref,\n\t\towner: { name, address }\n\t} = userData\n\ttry {\n\t\tconst requestBody = {\n\t\t\tpayment_channel,\n\t\t\tpayment_ref,\n\t\t\tname,\n\t\t\taddress\n\t\t}\n\t\tconst response = yield call(createCustomer, requestBody)\n\t\treturn response\n\t} catch (error) {\n\t\tconst { field } = error\n\t\tif (field) {\n\t\t\tthrow `Invalid Data Passed As \"${field}\"`\n\t\t}\n\t}\n}\nexport function* contractIdSaga({ payload: companyData }) {\n\tyield put(startLoading())\n\ttry {\n\t\tyield call(createCustomer, companyData)\n\t\tyield call(finishRegistrationProcedure)\n\t} catch (error) {\n\t\tconst { field } = error\n\t\tconst errorStatus = extractResponseErrorStatus(error)\n\t\tconst errorMessage = field\n\t\t\t? `Invalid Data Passed As \"${field}\"`\n\t\t\t: createResponseErrorMessage({\n\t\t\t\t\tspecificErrorHandler: {\n\t\t\t\t\t\tdefault: 'Error while generating Stripe Source Id'\n\t\t\t\t\t},\n\t\t\t\t\tstatus: errorStatus\n\t\t\t  })\n\t\tyield put(setContractIdError(errorMessage))\n\t} finally {\n\t\tyield put(finishLoading())\n\t}\n}\n\nexport function* finishRegistrationProcedure() {\n\t// const token = localStorage.getItem(LOCAL_ACCESS_TOKEN_KEY)\n\t// const decodedToken = jwt.decode(token, { json: true })\n\t// yield put(\n\t// \tloginSuccess({\n\t// \t\taccessToken: token,\n\t// \t\tcustomers: extractCustomers(decodedToken.roles)\n\t// \t})\n\t// )\n\tyield put(logoutUser())\n\thistory.push('/')\n}\n"]},"metadata":{},"sourceType":"module"}